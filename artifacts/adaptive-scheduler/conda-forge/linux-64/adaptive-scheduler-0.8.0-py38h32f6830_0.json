{
 "about": {
  "channels": [
   "conda-forge",
   "defaults"
  ],
  "conda_build_version": "3.19.2",
  "conda_private": false,
  "conda_version": "4.8.4",
  "description": "The Adaptive scheduler solves the following problem, you need to run a few 100\nlearners and can use >1k cores. `ipyparallel` and `dask.distributed` provide\nvery powerful engines for interactive sessions. However, when you want to\nconnect to >1k cores it starts to struggle. Besides that, on a shared cluster\nthere is often the problem of starting an interactive session with ample space\navailable. Our approach is to schedule a different job for each `\nadaptive.Learner`. The creation and running of these jobs are managed by `\nadaptive-scheduler`. This means that your calculation will definitely run, even\nthough the cluster might be fully occupied at the moment. Because of this\napproach, there is almost no limit to how many cores you want to use. You can\neither use 10 nodes for 1 job (`learner`) or 1 core for 1 job (`learner`) while\nscheduling hundreds of jobs. Everything is written such that the computation is\nmaximally local. This means that is one of the jobs crashes, there is no\nproblem and it will automatically schedule a new one and continue the\ncalculation where it left off (because of Adaptive's periodic saving\nfunctionality). Even if the central \"job manager\" dies, the jobs will continue\nto run (although no new jobs will be scheduled.)\n",
  "dev_url": "https://github.com/basnijholt/adaptive-scheduler",
  "doc_url": "http://adaptive-scheduler.readthedocs.io",
  "env_vars": {
   "CIO_TEST": "<not set>"
  },
  "extra": {
   "copy_test_source_files": true,
   "final": true,
   "recipe-maintainers": [
    "basnijholt"
   ]
  },
  "home": "http://github.com/basnijholt/adaptive-scheduler",
  "identifiers": [],
  "keywords": [],
  "license": "BSD-3-Clause",
  "license_family": "BSD",
  "license_file": "LICENSE",
  "root_pkgs": [
   "readline 8.0 he28a2e2_2",
   "patch 2.7.6 h14c3975_1001",
   "libedit 3.1.20191231 he28a2e2_2",
   "xz 5.2.5 h516909a_1",
   "attrs 20.1.0 pyh9f0ad1d_0",
   "pcre 8.44 he1b5a44_0",
   "pyopenssl 19.1.0 py_1",
   "libgcc-ng 9.3.0 h24d8f2e_16",
   "pyyaml 5.3.1 py37h8f50634_0",
   "c-ares 1.16.1 h516909a_3",
   "python-libarchive-c 2.9 py37_0",
   "urllib3 1.25.10 py_0",
   "jsonschema 3.2.0 py37hc8dfbb8_1",
   "git 2.28.0 pl526h5e3e691_1",
   "zlib 1.2.11 h516909a_1007",
   "pycparser 2.20 pyh9f0ad1d_2",
   "expat 2.2.9 he1b5a44_2",
   "ipython_genutils 0.2.0 py_1",
   "lz4-c 1.9.2 he1b5a44_3",
   "markupsafe 1.1.1 py37h8f50634_1",
   "zipp 3.1.0 py_0",
   "icu 67.1 he1b5a44_0",
   "cryptography 3.0 py37hb09aad4_0",
   "su-exec 0.2 h516909a_1002",
   "liblief 0.10.1 he1b5a44_1",
   "pytz 2020.1 pyh9f0ad1d_0",
   "nbformat 5.0.7 py_0",
   "pkginfo 1.5.0.1 py_0",
   "_libgcc_mutex 0.1 conda_forge",
   "decorator 4.4.2 py_0",
   "glob2 0.7 py_0",
   "requests 2.24.0 pyh9f0ad1d_0",
   "ruamel_yaml 0.15.80 py37h8f50634_1001",
   "zstd 1.4.5 h6597ccf_2",
   "beautifulsoup4 4.9.1 py_1",
   "jinja2 2.11.2 pyh9f0ad1d_0",
   "importlib_metadata 1.7.0 0",
   "libstdcxx-ng 9.3.0 hdf63c60_16",
   "bzip2 1.0.8 h516909a_3",
   "conda-build 3.19.2 py37hc8dfbb8_4",
   "tk 8.6.10 hed695b0_0",
   "python-dateutil 2.8.1 py_0",
   "setuptools 49.6.0 py37hc8dfbb8_0",
   "libev 4.33 h516909a_0",
   "ld_impl_linux-64 2.34 hc38a660_9",
   "certifi 2020.6.20 py37hc8dfbb8_0",
   "tqdm 4.48.2 pyh9f0ad1d_0",
   "conda 4.8.4 py37hc8dfbb8_2",
   "py-lief 0.10.1 py37h3340039_1",
   "conda-package-handling 1.7.0 py37h8f50634_4",
   "pysocks 1.7.1 py37hc8dfbb8_1",
   "pip 20.2.2 py_0",
   "traitlets 4.3.3 py37hc8dfbb8_1",
   "libiconv 1.16 h516909a_0",
   "pycosat 0.6.3 py37h8f50634_1004",
   "ca-certificates 2020.6.20 hecda079_0",
   "jupyter_core 4.6.3 py37hc8dfbb8_1",
   "importlib-metadata 1.7.0 py37hc8dfbb8_0",
   "yaml 0.2.5 h516909a_0",
   "sqlite 3.33.0 h4cf870e_0",
   "curl 7.71.1 he644dc0_5",
   "libarchive 3.3.3 hddc7a2b_1008",
   "lzo 2.10 h516909a_1000",
   "wheel 0.35.1 pyh9f0ad1d_0",
   "psutil 5.7.2 py37h8f50634_0",
   "openssl 1.1.1g h516909a_1",
   "tini 0.18.0 h14c3975_1001",
   "libffi 3.2.1 he1b5a44_1007",
   "libnghttp2 1.41.0 hab1572f_1",
   "filelock 3.0.12 pyh9f0ad1d_0",
   "patchelf 0.11 he1b5a44_0",
   "libxml2 2.9.10 h68273f3_2",
   "gettext 0.19.8.1 hc5be6a0_1002",
   "python 3.7.8 h6f2ec95_1_cpython",
   "soupsieve 2.0.1 py_1",
   "pyrsistent 0.16.0 py37h8f50634_0",
   "_openmp_mutex 4.5 1_gnu",
   "anaconda-client 1.7.2 py_0",
   "python_abi 3.7 1_cp37m",
   "brotlipy 0.7.0 py37h8f50634_1000",
   "cffi 1.14.1 py37h2b28604_0",
   "perl 5.26.2 h516909a_1006",
   "libgomp 9.3.0 h24d8f2e_16",
   "clyent 1.2.2 py_1",
   "chardet 3.0.4 py37hc8dfbb8_1006",
   "ripgrep 12.1.1 h516909a_0",
   "libcurl 7.71.1 hcdd3856_5",
   "idna 2.10 pyh9f0ad1d_0",
   "six 1.15.0 pyh9f0ad1d_0",
   "ncurses 6.2 he1b5a44_1",
   "libssh2 1.9.0 hab1572f_5",
   "krb5 1.17.1 hfafb76e_2",
   "jq 1.6 h14c3975_1000",
   "shyaml 0.6.1 py_0",
   "conda-forge-ci-setup 3.2.1 py37h71091ce_0",
   "click 7.1.2 pyh9f0ad1d_0",
   "oniguruma 6.9.3 h516909a_0",
   "conda-env 2.6.0 1"
  ],
  "summary": "An asynchronous scheduler for Adaptive",
  "tags": []
 },
 "conda_build_config": {
  "CI": "azure",
  "c_compiler": "gcc",
  "channel_sources": "conda-forge,defaults",
  "channel_targets": "conda-forge main",
  "cpu_optimization_target": "nocona",
  "cran_mirror": "https://cran.r-project.org",
  "cxx_compiler": "gxx",
  "docker_image": "condaforge/linux-anvil-comp7",
  "extend_keys": [
   "ignore_version",
   "pin_run_as_build",
   "ignore_build_only_deps",
   "extend_keys"
  ],
  "fortran_compiler": "gfortran",
  "ignore_build_only_deps": [
   "numpy",
   "python"
  ],
  "lua": "5",
  "numpy": "1.11",
  "perl": "5.26.0",
  "pin_run_as_build": {
   "python": {
    "max_pin": "x.x",
    "min_pin": "x.x"
   },
   "r-base": {
    "max_pin": "x.x",
    "min_pin": "x.x"
   }
  },
  "python": "3.8.* *_cpython",
  "r_base": "3.5",
  "target_platform": "linux-64"
 },
 "files": [
  "lib/python3.8/site-packages/adaptive_scheduler-0.8.0.dist-info/INSTALLER",
  "lib/python3.8/site-packages/adaptive_scheduler-0.8.0.dist-info/LICENSE",
  "lib/python3.8/site-packages/adaptive_scheduler-0.8.0.dist-info/METADATA",
  "lib/python3.8/site-packages/adaptive_scheduler-0.8.0.dist-info/RECORD",
  "lib/python3.8/site-packages/adaptive_scheduler-0.8.0.dist-info/REQUESTED",
  "lib/python3.8/site-packages/adaptive_scheduler-0.8.0.dist-info/WHEEL",
  "lib/python3.8/site-packages/adaptive_scheduler-0.8.0.dist-info/direct_url.json",
  "lib/python3.8/site-packages/adaptive_scheduler/__init__.py",
  "lib/python3.8/site-packages/adaptive_scheduler/_mock_scheduler.py",
  "lib/python3.8/site-packages/adaptive_scheduler/_static_version.py",
  "lib/python3.8/site-packages/adaptive_scheduler/_version.py",
  "lib/python3.8/site-packages/adaptive_scheduler/client_support.py",
  "lib/python3.8/site-packages/adaptive_scheduler/run_script.py.j2",
  "lib/python3.8/site-packages/adaptive_scheduler/scheduler.py",
  "lib/python3.8/site-packages/adaptive_scheduler/sequence_learner.py",
  "lib/python3.8/site-packages/adaptive_scheduler/server_support.py",
  "lib/python3.8/site-packages/adaptive_scheduler/utils.py",
  "lib/python3.8/site-packages/adaptive_scheduler/widgets.py"
 ],
 "index": {
  "arch": "x86_64",
  "build": "py38h32f6830_0",
  "build_number": 0,
  "depends": [
   "adaptive >=0.11",
   "cloudpickle",
   "dill",
   "ipyparallel",
   "jinja2",
   "loky",
   "mpi4py",
   "mpich",
   "numpy",
   "pandas",
   "psutil",
   "python >=3.8,<3.9.0a0",
   "python_abi 3.8.* *_cp38",
   "pyzmq",
   "structlog",
   "tinydb",
   "toolz",
   "tqdm"
  ],
  "license": "BSD-3-Clause",
  "license_family": "BSD",
  "name": "adaptive-scheduler",
  "platform": "linux",
  "subdir": "linux-64",
  "timestamp": 1598451994202,
  "version": "0.8.0"
 },
 "metadata_version": 1,
 "name": "adaptive-scheduler",
 "raw_recipe": "{% set name = \"adaptive-scheduler\" %}\n{% set version = \"0.8.0\" %}\n\npackage:\n  name: {{ name|lower }}\n  version: {{ version }}\n\nsource:\n  url: https://pypi.io/packages/source/{{ name[0] }}/{{ name }}/adaptive_scheduler-{{ version }}.tar.gz\n  sha256: 3ff9ef4b18286ff9a18cded9ba3ce1bc06bc7e4993699e010842559e8a561192\n\nbuild:\n  number: 0\n  skip: true  # [win]\n  skip: true  # [py<37]\n  script: {{ PYTHON }} -m pip install . --no-deps -vv\n\nrequirements:\n  host:\n    - python\n    - pip\n  run:\n    - python\n    - mpich\n    - adaptive >=0.11\n    - cloudpickle\n    - dill\n    - ipyparallel\n    - jinja2\n    - loky\n    - mpi4py\n    - numpy\n    - pandas\n    - psutil\n    - pyzmq\n    - structlog\n    - tinydb\n    - toolz\n    - tqdm\n\ntest:\n  imports:\n    - adaptive_scheduler\n\nabout:\n  home: http://github.com/basnijholt/adaptive-scheduler\n  license: BSD-3-Clause\n  license_family: BSD\n  license_file: LICENSE\n  summary: An asynchronous scheduler for Adaptive\n  description: |\n    The Adaptive scheduler solves the following problem, you need to run a few 100 \n    learners and can use >1k cores. `ipyparallel` and `dask.distributed` provide \n    very powerful engines for interactive sessions. However, when you want to \n    connect to >1k cores it starts to struggle. Besides that, on a shared cluster \n    there is often the problem of starting an interactive session with ample space \n    available. Our approach is to schedule a different job for each `\n    adaptive.Learner`. The creation and running of these jobs are managed by `\n    adaptive-scheduler`. This means that your calculation will definitely run, even \n    though the cluster might be fully occupied at the moment. Because of this \n    approach, there is almost no limit to how many cores you want to use. You can \n    either use 10 nodes for 1 job (`learner`) or 1 core for 1 job (`learner`) while \n    scheduling hundreds of jobs. Everything is written such that the computation is \n    maximally local. This means that is one of the jobs crashes, there is no \n    problem and it will automatically schedule a new one and continue the \n    calculation where it left off (because of Adaptive's periodic saving \n    functionality). Even if the central \"job manager\" dies, the jobs will continue \n    to run (although no new jobs will be scheduled.) \n  doc_url: http://adaptive-scheduler.readthedocs.io\n  dev_url: https://github.com/basnijholt/adaptive-scheduler\n\nextra:\n  recipe-maintainers:\n    - basnijholt\n",
 "rendered_recipe": {
  "about": {
   "description": "The Adaptive scheduler solves the following problem, you need to run a few 100\nlearners and can use >1k cores. `ipyparallel` and `dask.distributed` provide\nvery powerful engines for interactive sessions. However, when you want to\nconnect to >1k cores it starts to struggle. Besides that, on a shared cluster\nthere is often the problem of starting an interactive session with ample space\navailable. Our approach is to schedule a different job for each `\nadaptive.Learner`. The creation and running of these jobs are managed by `\nadaptive-scheduler`. This means that your calculation will definitely run, even\nthough the cluster might be fully occupied at the moment. Because of this\napproach, there is almost no limit to how many cores you want to use. You can\neither use 10 nodes for 1 job (`learner`) or 1 core for 1 job (`learner`) while\nscheduling hundreds of jobs. Everything is written such that the computation is\nmaximally local. This means that is one of the jobs crashes, there is no\nproblem and it will automatically schedule a new one and continue the\ncalculation where it left off (because of Adaptive's periodic saving\nfunctionality). Even if the central \"job manager\" dies, the jobs will continue\nto run (although no new jobs will be scheduled.)\n",
   "dev_url": "https://github.com/basnijholt/adaptive-scheduler",
   "doc_url": "http://adaptive-scheduler.readthedocs.io",
   "home": "http://github.com/basnijholt/adaptive-scheduler",
   "license": "BSD-3-Clause",
   "license_family": "BSD",
   "license_file": "LICENSE",
   "summary": "An asynchronous scheduler for Adaptive"
  },
  "build": {
   "number": "0",
   "script": "/home/conda/feedstock_root/build_artifacts/adaptive-scheduler_1598451881831/_h_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_pl/bin/python -m pip install . --no-deps -vv",
   "string": "py38h32f6830_0"
  },
  "extra": {
   "copy_test_source_files": true,
   "final": true,
   "recipe-maintainers": [
    "basnijholt"
   ]
  },
  "package": {
   "name": "adaptive-scheduler",
   "version": "0.8.0"
  },
  "requirements": {
   "host": [
    "_libgcc_mutex 0.1 conda_forge",
    "_openmp_mutex 4.5 1_gnu",
    "ca-certificates 2020.6.20 hecda079_0",
    "certifi 2020.6.20 py38h32f6830_0",
    "ld_impl_linux-64 2.34 hc38a660_9",
    "libffi 3.2.1 he1b5a44_1007",
    "libgcc-ng 9.3.0 h24d8f2e_16",
    "libgomp 9.3.0 h24d8f2e_16",
    "libstdcxx-ng 9.3.0 hdf63c60_16",
    "ncurses 6.2 he1b5a44_1",
    "openssl 1.1.1g h516909a_1",
    "pip 20.2.2 py_0",
    "python 3.8.5 h1103e12_5_cpython",
    "python_abi 3.8 1_cp38",
    "readline 8.0 he28a2e2_2",
    "setuptools 49.6.0 py38h32f6830_0",
    "sqlite 3.33.0 h4cf870e_0",
    "tk 8.6.10 hed695b0_0",
    "wheel 0.35.1 pyh9f0ad1d_0",
    "xz 5.2.5 h516909a_1",
    "zlib 1.2.11 h516909a_1007"
   ],
   "run": [
    "adaptive >=0.11",
    "cloudpickle",
    "dill",
    "ipyparallel",
    "jinja2",
    "loky",
    "mpi4py",
    "mpich",
    "numpy",
    "pandas",
    "psutil",
    "python >=3.8,<3.9.0a0",
    "python_abi 3.8.* *_cp38",
    "pyzmq",
    "structlog",
    "tinydb",
    "toolz",
    "tqdm"
   ]
  },
  "source": {
   "sha256": "3ff9ef4b18286ff9a18cded9ba3ce1bc06bc7e4993699e010842559e8a561192",
   "url": "https://pypi.io/packages/source/a/adaptive-scheduler/adaptive_scheduler-0.8.0.tar.gz"
  },
  "test": {
   "imports": [
    "adaptive_scheduler"
   ]
  }
 },
 "version": "0.8.0"
}